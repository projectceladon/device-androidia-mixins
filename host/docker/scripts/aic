#!/bin/bash

AIC_DATA_IMG=$(pwd)/workdir/aic_data.img
AIC_VG_NAME="aic_data"

function check_num {
    case $1 in
        ''|*[!0-9]*)
            return 1
            ;;
        *)
            return 0
            ;;
    esac
}

function check_docker {
    if [ ! -x "$(command -v docker)" ]; then
        echo "[AIC] docker not installed, please install it first!"
        exit -1
    fi
}

function check_kernel_header {
    if [ -z "$(ls /dev/binder* 2>/dev/null)" ] && [ ! -d "/lib/modules/$(uname -r)/build" ]; then
        echo "[AIC] Kernel headers not installed, please install it first using below commands:"
        if [ "$OS_TYPE" = "ubuntu" ]; then
            echo "sudo apt install linux-headers-\$(uname -r)"
        else
            echo -e "sudo ros service enable kernel-headers\nsudo ros service up kernel-headers"
        fi
        exit -1
    fi
}

function check_containers {
    if [ -z "$($DOCKER ps -a | awk '{print $NF}' | grep -w aic-manager)" ]; then
        echo "[AIC] aic-manager container not existed, please re-install aic!"
        exit -1
    fi
    if [ -z "$($DOCKER ps -a | awk '{print $NF}' | grep android)" ]; then
        echo "[AIC] android container not existed, please re-install aic!"
        exit -1
    fi
}

function check_data_img {
    if [ -f "$AIC_DATA_IMG" ];then
        echo "Detect previous data img..."
    else
        echo "Create data image..."
        dd if=/dev/zero of=$AIC_DATA_IMG bs=2M count=2048
    fi
}

function prepare_data_partition {
    data_name=$1
    # Check losetup settings
    if [ -z "$(losetup | grep $AIC_DATA_IMG)" ]; then
        loop_dev=`losetup -f`
        sudo losetup $loop_dev $AIC_DATA_IMG
    fi
    # Check pv
    if [ -z "$(sudo pvs | grep $AIC_VG_NAME)" ]; then
       sudo pvcreate $loop_dev
    fi
    # Check VG
    if [ -z "$(sudo vgs | grep $AIC_VG_NAME)" ]; then
        sudo vgcreate $AIC_VG_NAME $loop_dev
    else
       echo "VG $AIC_VG_NAME detected..."
        sudo vgchange -a y $AIC_VG_NAME
    fi
    # Check lv
    if [ -z "$(sudo lvs | grep $data_name)" ]; then
        sudo lvcreate -L 2G -T $AIC_VG_NAME/$data_name
    fi
    # make lvm node under dev
    sudo vgscan --mknodes -v
}

function delete_data_partition {
    if [ ! -z "$(sudo lvs | grep android)" ]; then
        CON_NAME=$(sudo lvs | grep -E 'android' | awk '{print $1}')
        echo "[AIC] Remove LVM for container ..."
        sudo lvremove -f /dev/$AIC_VG_NAME/$CON_NAME
    fi

    if [ ! -z "$(sudo vgs | grep $AIC_VG_NAME)" ]; then
        sudo vgremove -f /dev/$AIC_VG_NAME
    fi

    # Delete data image
    if [ ! -z "$(sudo losetup | grep $AIC_VG_NAME)" ]; then
       mounted_loop_dev=$(losetup | grep $AIC_VG_NAME | awk '{print $1}')
        echo "Detach mounted loop device, $mounted_loop_dev..."
        sudo pvremove -f $mounted_loop_dev
        sudo losetup -d $mounted_loop_dev
    fi

    if [ -d "/dev/$AIC_VG_NAME" ]; then
        echo "Delete /dev/$AIC_VG_NAME..."
        sudo rm -rf /dev/$AIC_VG_NAME
    fi

    if [ -f "$AIC_DATA_IMG" ]; then
        echo "Delete data image...."
        sudo rm -f $AIC_DATA_IMG
    fi
}

function parse_ids {
    if [ "${#IDS[@]}" -eq 0 ]; then
        CONTAINERS=($($DOCKER ps -a | awk '{print $NF}' | grep android))
    else
        for id in ${IDS[@]}
        do
            if [ -z "${id##*~*}" ]; then
                IFS='~' read -ra ID_RANGE <<< "$id"
                if [ "${#ID_RANGE[@]}" -ne 2 ] || ! check_num ${ID_RANGE[0]} || ! check_num ${ID_RANGE[1]}; then
                    echo "$USAGE"
                    exit -1
                fi
                for c in $(seq ${ID_RANGE[0]} ${ID_RANGE[1]})
                do
                    CONTAINERS+=(android$c)
                done
            else
                if ! check_num $id; then
                    echo "$USAGE"
                    exit -1
                fi
                CONTAINERS+=(android$id)
            fi
        done
    fi
}

function get_cpu_set()
{
    typeset -i container_id
    container_id=`expr $1`
    platform_type=$2

    if [ "$platform_type" = "nuc" ]; then
        cpu_num_str=`nproc --all`
        cpu_num=`expr $cpu_num_str`

        if [ $cpu_num -le 4 ];then
            interval=$cpu_num
        else
            interval=4
        fi

        loop_len=$(($cpu_num/$interval))
        remainder=$(($container_id%$loop_len))
        cpuset="$(($interval*$remainder))-$(($interval*$remainder+$interval-1))"

    elif [ "$platform_type" = "server" ]; then
        max_core_num=${#process_dict_key[@]}

        if [ $max_core_num -le 2 ];then
            interval=$max_core_num
        else
            interval=2
        fi
        loop_len=$(($max_core_num/$interval))
        remainder=$(($container_id%$loop_len))
        start_index=$(($interval*$remainder))
        end_index=$(($interval*$remainder+$interval-1))
        cpuset="${process_dict[${process_dict_key[$start_index]}]}${process_dict[${process_dict_key[$end_index]}]}"
        cpuset=${cpuset/%,}

    else
        echo "Unknow platform type, exit..."
        exit -1
    fi

    echo $cpuset
}

function get_socket_core_process_info()
{
    lscpu -p >> ./tmp_$$
    while read line; do
        if [[ "$line" == "#"* ]];then
            continue;
        fi

        p_id=`echo $line | cut -d "," -f 1`
        c_id=`echo $line | cut -d "," -f 2`
        s_id=`echo $line | cut -d "," -f 3`

        index_key=$s_id-$c_id
        process_dict+=([$index_key]="$p_id,")

    done < ./tmp_$$
    rm ./tmp_$$

    process_dict_key=( $(
        for key in ${!process_dict[@]}
        do
            echo "$key"
        done | sort ) )
}

# Get memory node id of all CPU
function get_all_cpu_mem_node() {
  local newarray
  newarray=($(echo "$@"))

  cut_ret=`lscpu -p | while read line; do  if [[ "$line" == "#"* ]];then continue; else echo $line | cut -d "," -f 4;i=$((i+1)); fi; done`
  for ((i=0;i<$cpu_num;i=i+1))
    do
          newarray[$i]=`echo $cut_ret | cut -d " " -f $((i+1))`
        done
  echo ${newarray[*]}
}

# Get memory node by cpu core id
function get_mem_node_by_cpuid() {

    typeset  mem_node_id

    cpu_ids=$(echo $1 | tr "," "\n")
    for _id in $cpu_ids
      do
        if [ -z $mem_node_id ]; then
          mem_node_id="${cpu_mem_node_arr[$_id]}"
        else
          mem_node_id="${cpu_mem_node_arr[$_id]},$mem_node_id"
        fi
      done

    echo $mem_node_id
}

function umount_binderfs() {
    if [[ $(findmnt -M "/dev/binderfs")  ]]; then
        echo "Umount binderfs..."
        find /dev/binderfs/*binder*[0-9] 2> /dev/null | while read line; do
            sudo unlink $line
        done
        sudo umount /dev/binderfs
    fi
}

function mount_binderfs() {
    if [ ! -d "/dev/binderfs"  ]; then
        echo "Create binderfs mount point /dev/binderfs..."
        sudo mkdir -p /dev/binderfs
    fi
    umount_binderfs
    sudo mount -t binder binder /dev/binderfs
}

function check_binderfs() {

    binder_kernel_config=`cat /lib/modules/$(uname -r)/build/.config 2>/dev/null | grep CONFIG_ANDROID_BINDERFS | cut -d "=" -f 2`
    if [ "$binder_kernel_config" == "y" ];then
        echo "Host kernel is compiled with CONFIG_ANDROID_BINDERFS=y, skip waiting for binder_linux module to be loaded..."
    else
        while [ -z "$(grep -e "binderfs_module" /proc/modules)" ]
        do
            echo "[AIC] Waiting for binderfs module installed..."
            sleep 1
        done
    fi
    mount_binderfs

}

SYSTEM_IMAGE_MOUNT_OPTIONS=
function get_system_image_mount_options() {
    images=$($DOCKER run --rm -it --entrypoint /bin/sh $AIC_MANAGER_IMAGE -c '[ -d /images ] && cd /images && ls *.img' | tr -d '\r')
    if [ -n "$images" ]; then
        mountd=$(pwd)/workdir/media
        echo "[AIC] system images: $images"
        for img in $images
        do
            name=$(basename $img .img)
            dest=$mountd/$name
            SYSTEM_IMAGE_MOUNT_OPTIONS="$SYSTEM_IMAGE_MOUNT_OPTIONS -v $dest:/$name:ro"
        done
        echo "[AIC] mount options: $SYSTEM_IMAGE_MOUNT_OPTIONS"
    fi
}

function setup_server_env()
{
    cpu_num=`expr \`nproc --all\``
    for ((i=0;i<$cpu_num;i=i+1))
    do
      cpu_mem_node_arr[i]=0
    done

    echo "Collecting socket/core/process/memory node Info, this may take a while..."
    # Gather all socket/core/process info
    get_socket_core_process_info

    # Gather all memory nodes information
    cpu_mem_node_arg=$(echo ${cpu_mem_node_arr[*]})
    cpu_mem_node_arr=($(get_all_cpu_mem_node $cpu_mem_node_arg))
}

function install {
    USAGE=$(cat <<- EOM

	Usage: aic install [OPTIONS]

	Load and install Android container images.

	Options:
	  -c, --cts                    Install AIC for CTS test enviroment.
	  -e, --emulated-input         Create and use emulated touch screen as primary input device. It's used
	                               by OpenSTF.
	  -i, --emulated-wifi          Create and use emulated wifi device for network connection.
	  -k, --detect-keyboard        Automaitically detect keyboard input device, this option is invalid
	                               when -m|--manually-input-config is set.
	  --host-dns-server            Use host's 172.100.0.1 network interface as Android's DNS server.
	  -m, --manually-input-config  Don't generate input configre files automatically.
	  -n, --instances int          Number of Android instances to be installed.
	  -p, --work-path string       Absolute path of work directory(relative path is not supported).
	  -a, --app-path string        Absolute path of intalled app directory
	  -d, --display-type string    Specify display type, valid option is 'drm', 'x11', 'wld', 'ia_hwc' and 'none'.
	  -t, --display-density string Specify display density.
	  -u, --update                 Use docker souces in update directory to build and install a new
	                               android image based on android.tar.gz.
	  -l, --platform string        Specify the hardware of platform to run AIC, valid option is 'server' and 'nuc'.
	  -b, --adb-port string        Specify adb port for instance 0.
	  -s, --rr-server string       Specify server address for Remote Rendering.
	  -f, --rr-server-file string  Specify config file of server address for Remote Rendering. It's invalid
	                               to specify -s -f at the same time.
	  -w, --multi-dis-daemon       Start multiple display daemons for every instance. It's only valid when
	                               display-type is 'x11' or 'wld' and instances number large than 1.
	  -j, --multi-user             Support multi-user, with this install option, we can use "aic start -u $AIC_USER" to start
	                               aic with user data for this user.
	  -g, --enable-fbe             Enable file-based encryption.

	Example:
	  Install 3 android instance and do not automatically generate input config file:
	    ./aic install -m -n 3
	  Install one android instance, automatically generate input config file and specify work path to ~/tmp/workdir:
	    ./aic install -p ~/tmp/workdir
	  Install one android instance, automatically generate input config file and support keyboard input detection.
	    ./aic install -k
	EOM
    )

    WORK_DIR="$(pwd)/workdir"
    APP_DIR="$WORK_DIR/app/installed"
    PLATFORM_HARDWARE="nuc"
    ADB_PORT="5555"
    INSTANCE_NUM="1"

    while [ "$#" -gt 0  ]
    do
        case "$1" in
            -c|--cts)
                CTS_ENV="true"
                SUPPORT_RESTART="true"
                EMULATED_WIFI="true"
                shift
                ;;
            -r|--restart)
                SUPPORT_RESTART="true"
                shift
                ;;
            -e|--emulated-input)
                EMULATED_INPUT="true"
                shift
                ;;
            -i|--emulated-wifi)
                EMULATED_WIFI="true"
                shift
                ;;
            -k|--detect-keyboard)
                DETECT_KEYBOARD="true"
                shift
                ;;
            --host-dns-server)
                HOST_DNS_SERVER="true"
                shift
                ;;
            -m|--manually-input-config)
                MANUALLY_INPUT_CONFIG="true"
                shift
                ;;
            -n|--instances)
                shift
                if [ "$#" -lt 1 ]; then
                    echo "$USAGE"
                    exit -1
                fi
                INSTANCE_NUM=$1
                if ! check_num $INSTANCE_NUM; then
                    echo "$USAGE"
                    exit -1
                fi
                if [ "$INSTANCE_NUM" -lt 1 ]; then
                    echo "$USAGE"
                    exit -1
                fi
                shift
                ;;
            -p|--work-path)
                shift
                if [ "$#" -lt 1 ]; then
                    echo "$USAGE"
                    exit -1
                fi
                WORK_DIR=$1
                shift
                ;;
            -a|--app-path)
                shift
                if [ "$#" -lt 1 ]; then
                    echo "$USAGE"
                    exit -1
                fi
                APP_DIR=$1
                shift
                ;;
            -d|--display-type)
                shift
                if [ "$#" -lt 1 ]; then
                    echo "$USAGE"
                    exit -1
                fi
                DISPLAY_TYPE=$1
                if [ ! "$DISPLAY_TYPE" = "drm" ] && [ ! "$DISPLAY_TYPE" = "x11" ] && [ ! "$DISPLAY_TYPE" = "wld" ] && [ ! "$DISPLAY_TYPE" = "ia_hwc" ] && [ ! "$DISPLAY_TYPE" = "none" ]; then
                    echo "$USAGE"
                    exit -1
                fi
                shift
                ;;
            -u|--update)
                ANDROID_UPDATE="true"
                shift
                ;;
            -l|--platform)
                shift
                PLATFORM_HARDWARE=$1
                if [ ! "$PLATFORM_HARDWARE" = "server" ] && [ ! "$PLATFORM_HARDWARE" = "nuc" ]; then
                    echo "$USAGE"
                    exit -1
                fi
                 shift
                 ;;
            -b|--adb-port)
                shift
                if [ "$#" -lt 1 ]; then
                    echo "$USAGE"
                    exit -1
                fi
                ADB_PORT=$1
                if ! check_num $ADB_PORT; then
                    echo "$USAGE"
                    exit -1
                fi
                shift
                ;;
            -t|--display-density)
                shift
                if [ "$#" -lt 1 ]; then
                    echo "$USAGE"
                    exit -1
                fi
                DISPLAY_DENSITY=$1
                shift
                ;;
            -s|--rr-server)
                shift
                if [ "$#" -lt 1 ]; then
                    echo "$USAGE"
                    exit -1
                fi
                RR_SERVER=$1
                shift
                ;;
            -f|--rr-server-file)
                shift
                if [ "$#" -lt 1 ]; then
                    echo "$USAGE"
                    exit -1
                fi
                RR_SERVER_FILE=$1
                shift
                ;;
            -w|--multi-dis-daemon)
                MULTIPLE_DISPLAY_DAEMON="true"
                shift
                ;;
            -g|--enable-fbe)
                ENABLE_FBE="true"
                shift
                ;;
            -j|--multi-user)
                MULTIPLE_USER="true"
                shift
                ;;
            *)
                echo "$USAGE"
                exit -1
                ;;
        esac
    done
    check_docker
    check_kernel_header

    if [ ! -z "$RR_SERVER" ] && [ ! -z "$RR_SERVER_FILE" ]; then
        echo "$USAGE"
        exit -1
    fi
    if [ ! -z "$RR_SERVER_FILE" ] && [ ! -e "$RR_SERVER_FILE" ]; then
        echo "[AIC] Missing RR server config file!"
        exit -1
    fi
    if [ "$MULTIPLE_DISPLAY_DAEMON" = "true" ]; then
        if [ "$INSTANCE_NUM" -lt 2 ]; then
            echo "$USAGE"
            exit -1
        fi
        if [ ! "$DISPLAY_TYPE" = "x11" ] && [ ! "$DISPLAY_TYPE" = "wld" ]; then
            echo "$USAGE"
            exit -1
        fi
    fi
    if [ "$MULTIPLE_USER" = "true" ] && [ "$INSTANCE_NUM" -gt 1 ]; then
        echo "[AIC] multi-user flag can only be used for single instance!"
        exit -1
    fi

    if [ "$DISPLAY_TYPE" = "ia_hwc" ]; then
        cp -r ia_hwc/* update/
    fi

    AIC_MANAGER_IMAGE_FILE=aic-manager.tar.gz
    ANDROID_IMAGE_FILE=android.tar.gz
    AIC_MANAGER_IMAGE=aic-manager:latest
    ANDROID_IMAGE=android:latest
    if [ ! -z "$IMAGE_TAG" ]; then
        AIC_MANAGER_IMAGE="aic-manager:$IMAGE_TAG"
        ANDROID_IMAGE="android:$IMAGE_TAG"
    fi
    if [ ! -e "$AIC_MANAGER_IMAGE_FILE" ] || [ ! -e "$ANDROID_IMAGE_FILE" ]; then
        echo "[AIC] Missing Android or aic-manager docker image files, plese check you installation!"
        exit -1
    fi
    if [ "$ANDROID_UPDATE" = "true" ]; then
        if [ ! -e "./update/Dockerfile" ] || [ ! -d "./update/root" ]; then
            echo "[AIC] Missing docker sources(./update/Dockerfile or ./update/root) to do android image update!"
            exit -1
        fi
    fi

    # Create workdir and app direcotry first, otherwise Docker may create it with root permission
    if [ ! -e "$WORK_DIR" ]; then
        mkdir -p $WORK_DIR
        mkdir -p $WORK_DIR/ipc
        chmod a+rw $WORK_DIR/ipc
    fi
    if [ ! -e "$APP_DIR" ]; then
        mkdir -p $APP_DIR
    fi

    if [ "$EMULATED_INPUT" = "true" ]; then
        MANUALLY_INPUT_CONFIG="true"
        if [ ! -d "$WORK_DIR/ipc/config/input" ]; then
            mkdir -p $WORK_DIR/ipc/config/input
        fi
    fi

    # uninstall previous resources
    if [ ! -z "$($DOCKER ps -a | grep -E 'android|aic-manager')" ] || [ ! -z "$($DOCKER images | grep -E 'android|aic-manager')" ]; then
        echo "[AIC] Uninstall existing resources first..."
        uninstall
    fi

    # set up server running environment if needed.
    if [ "$PLATFORM_HARDWARE" = "server" ]; then
        echo "[AIC] Setup running env for server platform..."
        # Init dict and array needed by assign cpu set
        declare -A process_dict
        declare -a process_dict_key
        # Init arry
        declare -a cpu_mem_node_arr
        setup_server_env
    fi

    # install docker network driver
    if [ -z "$($DOCKER network ls | grep android)" ]; then
        echo "[AIC] Create android network driver..."
        $DOCKER network create android --subnet=172.100.0.0/16 --gateway=172.100.0.1 -o "com.docker.network.bridge.name"="br-android" -o "com.docker.network.bridge.enable_icc"="true"
    fi

    # load docker images
    echo "[AIC] Load images..."
    $DOCKER load -i $AIC_MANAGER_IMAGE_FILE
    $DOCKER load -i $ANDROID_IMAGE_FILE
    if [ "$ANDROID_UPDATE" = "true" ]; then
        $DOCKER tag $ANDROID_IMAGE android_base
        $DOCKER rmi $ANDROID_IMAGE
        $DOCKER build -t $ANDROID_IMAGE update
    fi

    # create aic-manager container
    AIC_MANAGER_CONTAINER_OPTION="-v /lib/modules:/lib/modules -v /dev/mapper:/dev/mapper -v /usr/src:/usr/src -v $WORK_DIR/ipc:/ipc -v $WORK_DIR/media:/media:shared"
    AIC_MANAGER_CONTAINER_CMDS="-n $INSTANCE_NUM"
    if [ "$EMULATED_WIFI" = "true" ]; then
        AIC_MANAGER_CONTAINER_OPTION="$AIC_MANAGER_CONTAINER_OPTION -v /proc:/hostproc -v /var/run/docker.sock:/var/run/docker.sock"
    fi
    if [ "$MULTIPLE_USER" = "true" ]; then
        AIC_MANAGER_CONTAINER_OPTION="$AIC_MANAGER_CONTAINER_OPTION -v $WORK_DIR/data-multi-user:/data-multi-user -v $WORK_DIR/data0:/data0:shared"
        AIC_MANAGER_CONTAINER_CMDS="$AIC_MANAGER_CONTAINER_CMDS -j"
        if [ ! -d "$WORK_DIR/data-multi-user/data" ]; then
            mkdir -p $WORK_DIR/data-multi-user/data
        fi
    fi
    if [ "$MANUALLY_INPUT_CONFIG" = "true" ]; then
        AIC_MANAGER_CONTAINER_CMDS="$AIC_MANAGER_CONTAINER_CMDS -m"
    fi
    if [ "$DETECT_KEYBOARD" = "true" ]; then
        AIC_MANAGER_CONTAINER_CMDS="$AIC_MANAGER_CONTAINER_CMDS -k"
    fi
    if [ "$MULTIPLE_DISPLAY_DAEMON" = "true" ]; then
        AIC_MANAGER_CONTAINER_CMDS="$AIC_MANAGER_CONTAINER_CMDS -w"
    fi
    if [ "$EMULATED_WIFI" = "true" ]; then
        AIC_MANAGER_CONTAINER_CMDS="$AIC_MANAGER_CONTAINER_CMDS -i"
    fi
    if [ ! -z "$DISPLAY_TYPE" ]; then
        if [ "$DISPLAY_TYPE" = "x11" ]; then
            AIC_MANAGER_CONTAINER_CMDS="$AIC_MANAGER_CONTAINER_CMDS -d x11"
            AIC_MANAGER_CONTAINER_OPTION="$AIC_MANAGER_CONTAINER_OPTION -v /tmp/.X11-unix:/tmp/.X11-unix"
        elif [ "$DISPLAY_TYPE" = "wld" ]; then
            AIC_MANAGER_CONTAINER_CMDS="$AIC_MANAGER_CONTAINER_CMDS -d wld"
            AIC_MANAGER_CONTAINER_OPTION="$AIC_MANAGER_CONTAINER_OPTION -v /run/user/$(id -u):/tmp"
        elif [ "$DISPLAY_TYPE" = "drm" ]; then
            AIC_MANAGER_CONTAINER_CMDS="$AIC_MANAGER_CONTAINER_CMDS -d drm"
        fi
    else
        if [ "$OS_TYPE" = "ubuntu" ]; then
            AIC_MANAGER_CONTAINER_CMDS="$AIC_MANAGER_CONTAINER_CMDS -d x11"
            AIC_MANAGER_CONTAINER_OPTION="$AIC_MANAGER_CONTAINER_OPTION -v /tmp/.X11-unix:/tmp/.X11-unix"
        elif [ "$OS_TYPE" = "rancher" ]; then
            AIC_MANAGER_CONTAINER_CMDS="$AIC_MANAGER_CONTAINER_CMDS -d drm"
        fi
    fi
    if [ "$PLATFORM_HARDWARE" = "server" ]; then
       AIC_MANAGER_CONTAINER_OPTION="$AIC_MANAGER_CONTAINER_OPTION --pid host -v aic_isolate_cpu:/cpu "
       AIC_MANAGER_CONTAINER_CMDS="$AIC_MANAGER_CONTAINER_CMDS -l $PLATFORM_HARDWARE"
    fi
    if [ "$SUPPORT_RESTART" = "true" ]; then
        AIC_MANAGER_CONTAINER_OPTION="$AIC_MANAGER_CONTAINER_OPTION --restart unless-stopped"
    fi

    echo "[AIC] create aic-manager container..."
    $DOCKER container create --name aic-manager --init --net host --privileged=true $AIC_MANAGER_CONTAINER_OPTION $AIC_MANAGER_IMAGE $AIC_MANAGER_CONTAINER_CMDS

    # Check data image file
    if [ "$ENABLE_FBE" = "true" ]; then
        check_data_img
    fi

    # create Android containers
    ANDROID_CONTAINER_OPTION="-v $APP_DIR:/oem/app:ro -v $WORK_DIR/ipc:/ipc -v /dev/binderfs:/binderfs:rw -v /dev/usb:/data/misc/usb"
    get_system_image_mount_options && ANDROID_CONTAINER_OPTION="$ANDROID_CONTAINER_OPTION $SYSTEM_IMAGE_MOUNT_OPTIONS"
    if [ ! -z "$DISPLAY_DENSITY" ]; then
        ANDROID_CONTAINER_CMDS="-t $DISPLAY_DENSITY"
    fi
    if [ ! -z "$RR_SERVER" ]; then
        ANDROID_CONTAINER_CMDS="$ANDROID_CONTAINER_CMDS -s $RR_SERVER"
    fi
    if [ "$HOST_DNS_SERVER" = "true" ]; then
        ANDROID_CONTAINER_CMDS="$ANDROID_CONTAINER_CMDS -d"
    fi
    if [ "$EMULATED_INPUT" = "true" ]; then
        ANDROID_CONTAINER_CMDS="$ANDROID_CONTAINER_CMDS -e"
    fi
    if [ "$MULTIPLE_DISPLAY_DAEMON" = "true" ]; then
        ANDROID_CONTAINER_CMDS="$ANDROID_CONTAINER_CMDS -w"
    fi

    echo "[AIC] create android container..."
    ANDROID_CONTAINER_OPTION_BK=$ANDROID_CONTAINER_OPTION
    ANDROID_CONTAINER_CMDS_BK=$ANDROID_CONTAINER_CMDS

    for i in $(seq $(($INSTANCE_NUM - 1)) -1 0)
    do
        MAC=02:42:ac:64:$(printf "%02x" $(($i / 256))):$(printf "%02x" $(($i % 256)))
        IP=172.100.$((($i + 2) / 256)).$((($i + 2) % 256))


        if [ "$ENABLE_FBE" = "true" ]; then
            ANDROID_CONTAINER_OPTION="$ANDROID_CONTAINER_OPTION_BK -v /dev/$AIC_VG_NAME:/dev/$AIC_VG_NAME"
        else
            ANDROID_CONTAINER_OPTION="$ANDROID_CONTAINER_OPTION_BK -v $WORK_DIR/data$i:/data"
        fi
        ANDROID_CONTAINER_CMDS=$ANDROID_CONTAINER_CMDS_BK

        CPU_SET=$(get_cpu_set $i $PLATFORM_HARDWARE)

        if [ "$PLATFORM_HARDWARE" = "server" ]; then
            ANDROID_CONTAINER_OPTION="$ANDROID_CONTAINER_OPTION -v aic_isolate_cpu:/sys/devices/system/cpu"
            MEM_NODES=$(get_mem_node_by_cpuid $CPU_SET)
        fi

        if [ ! -z "$RR_SERVER_FILE" ] && [ ! -z "$(awk ''NR==$((i+1))'' $RR_SERVER_FILE)" ]; then
            ANDROID_CONTAINER_CMDS="$ANDROID_CONTAINER_CMDS -s $(awk ''NR==$((i+1))'' $RR_SERVER_FILE)"
        fi

        if [ "$ENABLE_FBE" = "true" ]; then
            ANDROID_CONTAINER_CMDS="$ANDROID_CONTAINER_CMDS -f"
        fi

        if [ "$EMULATED_WIFI" = "true" ] && [ "$CTS_ENV" != "true" ]; then
            ANDROID_CONTAINER_OPTION="$ANDROID_CONTAINER_OPTION -v $WORK_DIR/ipc/config/wifi/$i:/data/misc/wifi"
        fi
        if [ "$SUPPORT_RESTART" = "true" ]; then
            ANDROID_CONTAINER_OPTION="$ANDROID_CONTAINER_OPTION --restart unless-stopped --ulimit memlock=16777216"
        fi
        if [ "$CTS_ENV" != "true" ]; then
            ANDROID_CONTAINER_OPTION="$ANDROID_CONTAINER_OPTION --net android --ip $IP --mac-address $MAC -p $(($ADB_PORT+i)):5555"
        fi

        ANDROID_CONTAINER_OPTION="$ANDROID_CONTAINER_OPTION -v $WORK_DIR/audio:/ipc/config/audio"
        $DOCKER container create --name android$i --cpuset-cpus=$CPU_SET --cpuset-mems=${MEM_NODES:-0} --privileged=true $ANDROID_CONTAINER_OPTION $ANDROID_IMAGE $ANDROID_CONTAINER_CMDS $i

    done
}

function uninstall {
    USAGE=$(cat <<- EOM

	Usage: aic uninstall

	Clean up all Android containers which was installed before.
	EOM
    )

	if [ "$#" -lt 0 ]; then
		echo "$USAGE"
		exit 0
	fi

    check_docker

    if [ ! -z "$($DOCKER ps | awk '{print $NF}' | grep -E 'android|aic-manager')" ]; then
        echo "[AIC] Stop containers..."
        stop
    fi

    # rm containers
    CONTAINERS=$($DOCKER ps -a | awk '{print $NF}' | grep -E 'android|aic-manager')
    if [ ! -z "$CONTAINERS" ]; then
        echo "[AIC] rm containers..."
        $DOCKER rm $CONTAINERS
    fi

    # rm images
    IMAGES=$($DOCKER images | grep -E 'android|aic-manager' | awk '{print $3}')
    if [ ! -z "$IMAGES" ]; then
        echo "[AIC] rm images..."
        $DOCKER rmi $IMAGES
    fi

    # remove docker network
    if [ ! -z "$($DOCKER network ls | awk '{print $2}' | grep -w android)" ]; then
        echo "[AIC] rm android network driver"
        $DOCKER network rm android
    fi

    # Delete data partition
    delete_data_partition
}

function start {
    USAGE=$(cat <<- EOM

	Usage: aic start [OPTIONS] [ID | ID1 ID2...| ID1~ID2]

	Start Android containers. If there's no ID given, it will start all Android containers.

	Options:
	  -t, --time int               Seconds to wait before start next container.
	  -u, --user string            Start with user id for multi-user case.

	Example:
	  Start all android instances:
	    ./aic start
	  Start android instance 0, 1, 5 to 7.
	    ./aic start 0 1 5~7
	  Start all android instances, delay 5s after start one.
	EOM
    )

    IDS=()
    CONTAINERS=()
    MULTI_USER_DIR=$(echo -n $($DOCKER inspect -f '{{ range .Mounts }}{{ if eq .Destination "/data-multi-user" }}{{ .Source }}{{ end }} {{ end }}' aic-manager 2>/dev/null))
    while [ "$#" -gt 0  ]
    do
        case "$1" in
            -t|--time)
                shift
                if [ "$#" -lt 1 ]; then
                    echo "$USAGE"
                    exit -1
                fi
                WAIT_TIME=$1
                if ! check_num $WAIT_TIME; then
                    echo "$USAGE"
                    exit -1
                fi
                shift
                ;;
            -u|--user)
                shift
                if [ "$#" -lt 1 ]; then
                    echo "$USAGE"
                    exit -1
                fi
                if [ -z "$MULTI_USER_DIR" ]; then
                    echo "[AIC] current aic didn't install with multi-user flag!"
                    exit -1
                fi
                AIC_USER=$1
                if [[ "$AIC_USER" =~ .*/.* ]]; then
                    echo "[AIC] invalid user name!"
                    exit -1
                fi
                shift
                ;;
            -h|--help)
                echo "$USAGE"
                exit
                ;;
            *)
                IDS+=($1)
                shift
                ;;
        esac
    done

    check_docker
    check_containers
    parse_ids

    if [ ! -z "$AIC_USER" ]; then
        # Stop current running containers if any
        PRIVOUS_CONTAINERS=$($DOCKER ps | awk '{print $NF}' | grep -E 'android|aic-manager')
        if [ ! -z "$PRIVOUS_CONTAINERS" ]; then
            echo "[AIC] Stop previous running containers..."
            $DOCKER stop -t0 $PRIVOUS_CONTAINERS
        fi
        # umount multi-user data partition if any
        sudo umount $(dirname $MULTI_USER_DIR)/data0 2>/dev/null

        rm -rf $MULTI_USER_DIR/control
        mkdir -p $MULTI_USER_DIR/control
        echo $AIC_USER > $MULTI_USER_DIR/control/current_user
    elif [ ! -z "$MULTI_USER_DIR" ]; then
        echo "[AIC] current aic install with multi-user flag, please user 'aic start -u' to launch!"
	exit -1
    fi

    if [ -z "$($DOCKER ps | awk '{print $NF}' | grep -w aic-manager)" ]; then
        if [ "$OS_TYPE" = "ubuntu" ]; then
            export DISPLAY=:0
            xhost +local:$($DOCKER inspect --format='{{ .Config.Hostname }}' aic-manager) > /dev/null 2>&1
        fi
        sudo modprobe ashmem_module 2>/dev/null
        sudo modprobe binder_module 2>/dev/null
        sudo modprobe binderfs_module 2>/dev/null
        $DOCKER start aic-manager

        check_binderfs

        if [ ! -z "$AIC_USER" ]; then
            while [ -z "$(ls $MULTI_USER_DIR/control/data_ready 2>/dev/null)" ]
            do
                echo "[AIC] wait for preparing multi-user data partition..."
                sleep 1
            done
        fi
    fi

    EXISTED_CONTAINERS=$($DOCKER ps -a | awk '{print $NF}' | grep android)


    while [ -z "$(ls /dev/ashmem 2>/dev/null)" ]
    do
        echo "[AIC] wait for ashmem driver to be installed..."
        sleep 1
    done

    if [ "$LOOP_MOUNT_SYSTEM" = "true" ]; then
        while [ -z "$(ls $(pwd)/workdir/media/system 2>/dev/null)" ]
        do
            echo "[AIC] system image hasn't been mounted yet, wait..."
            sleep 1
        done
    fi

    for c in ${CONTAINERS[@]}
    do
        if [[ ! $EXISTED_CONTAINERS =~ (^|[[:space:]])"$c"($|[[:space:]]) ]]; then
            echo "[AIC] $c not existed!"
        else
            if [ ! -z "$($DOCKER inspect --format='{{.Config.Cmd}}' $c | grep "\-f")" ]; then
                prepare_data_partition $c
            fi
            $DOCKER start $c

            if [ ! -z "$WAIT_TIME" ]; then
                sleep $WAIT_TIME
            fi
        fi
    done

    if [[ $WLAN_PT == "true" ]] ; then
	ANDROID_PID=$(docker inspect -f '{{.State.Pid}}' android0)
	INTF=$(iw dev | awk '$1=="Interface"{print $2}')
	iw phy phy0 set netns $ANDROID_PID
	rfkill unblock all
	nsenter -t $ANDROID_PID -n ip link set $INTF name wlan0
    fi

}

function stop {
    USAGE=$(cat <<- EOM

	Usage: aic stop [ID | ID1 ID2...| ID1~ID2]

	Stop Android containers. If there's no ID given, it will stop all Android containers.

	Example:
	  Stop all android instances:
	    ./aic stop
	  Stop android instance 0, 1, 5 to 7.
	    ./aic stop 0 1 5~7
	EOM
    )

    IDS=()
    CONTAINERS=()
    while [ "$#" -gt 0  ]
    do
        case "$1" in
            -h|--help)
                echo "$USAGE"
                exit
                ;;
            *)
                IDS+=($1)
                shift
                ;;
        esac
    done

    check_docker
    check_containers
    parse_ids

    EXISTED_CONTAINERS=$($DOCKER ps -a | awk '{print $NF}' | grep android)

    for c in ${CONTAINERS[@]}
    do
        if [[ ! $EXISTED_CONTAINERS =~ (^|[[:space:]])"$c"($|[[:space:]]) ]]; then
            echo "[AIC] $c not existed!"
        else
            $DOCKER stop -t0 $c
        fi
    done

    if [ -z "$($DOCKER ps | awk '{print $NF}' | grep android)" ] && [ ! -z "$($DOCKER ps | awk '{print $NF}' | grep -w aic-manager)" ]; then
        $DOCKER stop aic-manager
    fi

    # umount binderfs mount point if any
    umount_binderfs

    # umount multi-user data partition if any
    MULTI_USER_DIR=$(echo -n $($DOCKER inspect -f '{{ range .Mounts }}{{ if eq .Destination "/data-multi-user" }}{{ .Source }}{{ end }} {{ end }}' aic-manager 2>/dev/null))
    if [ ! -z "$MULTI_USER_DIR" ]; then
	sudo umount $(dirname $MULTI_USER_DIR)/data0 2>/dev/null
    fi
}

function list {
    USAGE=$(cat <<- EOM

	Usage: aic list [OPTIONS]

	List Android containers.

	Option:
	  -a, --all             Show all Android containers (default shows just running)
	EOM
    )

    while [ "$#" -gt 0  ]
    do
        case "$1" in
            -a|--all)
                shift
                LIST_PARA="-a"
                ;;
            *)
                echo "$USAGE"
                exit 0
                ;;
        esac
    done

    $DOCKER ps $LIST_PARA -f name=android
}

OS_TYPE="ubuntu"

if [ ! -z "$(uname -r | grep rancher)"  ]; then
    OS_TYPE="rancher"
fi

if [ -z "$(docker ps 2>/dev/null)" ]; then
    DOCKER="sudo docker"
else
    DOCKER="docker"
fi

USAGE=$(cat <<- EOM

Usage: aic COMMAND

Android container manager tool.

Commands:
  install        Load and install Android container images.
  uninstall      Clean up all Android containers which was installed before.
  start          Start Android containers.
  stop           Stop Android containers.
  list           List Android contianers.

Run 'aic COMMAND --help' for more information on a command.
EOM
)

subcmd="$1"
case $subcmd in
    install)
        shift
        install $@
        ;;

    uninstall)
        shift
        uninstall $@
        ;;

    start)
        shift
        start $@
        ;;

    stop)
        shift
        stop $@
        ;;

    list)
        shift
        list $@
        ;;

    *)
        echo "$USAGE"
        exit
        ;;
esac

exit
